-- Obsidian UI Freemium
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/Library.lua"))()

-- Сначала получаем все необходимые сервисы
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
-- Ждем пока игрок загрузится
local player
if Players.LocalPlayer then
    player = Players.LocalPlayer
else
    Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
    player = Players.LocalPlayer
end

-- Переменная для хранения выбранной игры
local SelectedGame = nil

local Window = Library:CreateWindow({
    Title = "Cube's Hub Premium",
    Footer = "© Cube's Hub",
    Size = UDim2.fromOffset(550, 480),
    AutoShow = true,
    Center = true  -- Убрали неправильный параметр Icon
})

local InfoTab = Window:AddTab({
    Name = "Info",
    Description = "Our official accounts on social media",
    Icon = "info"
})


local MainTab = Window:AddTab({
    Name = "General",
    Description = "Welcome this basic universal functions",
    Icon = "user"
})

local ConfigTab = Window:AddTab({
    Name = "Settings",
    Description = "Customize the UI and more..",
    Icon = "settings"
})

-- Enable/disable the custom cursor
Library.ShowCustomCursor = false

-- Main features
local FeaturesBox = MainTab:AddLeftTabbox("Features")
local Visual = MainTab:AddLeftTabbox("Visual")
local GeneralTab = FeaturesBox:AddTab("Player")
local GamesBox = MainTab:AddRightTabbox("Game Scripts")

-- Создаем группу для игроков (Teleport) ПЕРВОЙ
local PlayerBox = MainTab:AddRightGroupbox("Teleport")
local OtherScripts = MainTab:AddRightGroupbox("Other Scripts")

local ColorUi = Color3.fromRGB(0, 255, 0)
Library.Scheme.AccentColor = ColorUi
Library:UpdateColorsUsingRegistry()

-- Выпадающий список для выбора игрока
local PlayerSelector = PlayerBox:AddDropdown("PlayerList", {
    SpecialType = "Player",
    Text = "Select Player",
    Tooltip = "Select a player to target",
    Callback = function(Value)
        SelectedPlayer = Value
        print("Selected player:", Value)
    end
})

-- Кнопка для телепортации к выбранному игроку
local TPButton = PlayerBox:AddButton({
    Text = "🎉 Teleport to Player",
    Func = function()
        if SelectedPlayer then
            local targetCharacter = SelectedPlayer.Character
            if targetCharacter then
                local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local myCharacter = player.Character
                    if myCharacter then
                        local myRoot = myCharacter:FindFirstChild("HumanoidRootPart")
                        if myRoot then
                            myRoot.CFrame = targetRoot.CFrame
                            print("Teleported to", SelectedPlayer.Name)
                        else
                            print("Your character doesn't have HumanoidRootPart")
                        end
                    else
                        print("Your character doesn't exist")
                    end
                else
                    print("Target player doesn't have HumanoidRootPart")
                end
            else
                print("Target player doesn't have a character")
            end
        else
            print("No player selected")
        end
    end,
    DoubleClick = false
})

local ServerHopButton = PlayerBox:AddButton({
    Text = "🚪 Server Hop",
    Tooltip = "Hop to another game",
    Func = function()
        Library:Notify("Server Hopping please wait..")
        print("Button clicked!")

        local PlaceID = game.PlaceId
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour

        local function TPReturner()
            local Site;
            if foundAnything == "" then
                Site = game:GetService("HttpService"):JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
            else
                Site = game:GetService("HttpService"):JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
            end

            if Site and Site.data then
                local ID = ""
                if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
                    foundAnything = Site.nextPageCursor
                else
                    foundAnything = ""
                end

                for i, v in pairs(Site.data) do
                    local Possible = true
                    ID = tostring(v.id)
                    if tonumber(v.maxPlayers) > tonumber(v.playing) then
                        for _, Existing in pairs(AllIDs) do
                            if ID == tostring(Existing) then
                                Possible = false
                                break
                            end
                        end
                        if Possible then
                            table.insert(AllIDs, ID)
                            wait(0.5)
                            game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                            wait(2)
                            return true
                        end
                    end
                end
            end
            return false
        end

        local function Teleport()
            local attempts = 0
            while attempts < 10 do
                pcall(function()
                    if TPReturner() then
                        return
                    end
                end)
                attempts = attempts + 1
                wait(5) -- Ждем 5 секунд перед следующей попыткой
            end
            Library:Notify("Failed to find a server after 10 attempts.")
        end

        spawn(Teleport)
    end,
    DoubleClick = true
})

local RegjoinServerButton = PlayerBox:AddButton({
 Text = "🔁 Rejoin Server",
 Tooltip = "Rejoin on server thats you playing",
 Func = function()
 Library:Notify("Rejoining please wait..")
 print("Button clicked!")
 wait(1)
 game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId)
 end,
 DoubleClick = true -- Requires double-click for risky actions
})

local PrivateServerButton = PlayerBox:AddButton({
 Text = "🔱 Private Server",
 Tooltip = "Join Free Private Server",
 Func = function()
 Library:Notify("Teleporting please wait..")
 print("Button clicked!")
 wait(1)
 local code = game:HttpGet("https://api.mspaint.cc/reserve/" .. tostring(game.PlaceId))
 game:GetService("RobloxReplicatedStorage").ContactListIrisInviteTeleport:FireServer(game.PlaceId, "", code)
 end,
 DoubleClick = true -- Requires double-click for risky actions
})

local Button = OtherScripts:AddButton({
 Text = "Infinite Yield",
 Func = function()
 loadstring(game:HttpGet(('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'),true))()
 print("Loading inf yeild")
 wait(0.4)
 Library:Notify("Loaded Infinite Yield ❤")
 end,
 DoubleClick = false -- Requires double-click for risky actions
})

local GamesTab = GamesBox:AddTab("Games")

-- Переменная для хранения выбранной игры
local SelectedGame = nil

-- Выпадающий список для выбора игры
local GameSelector = GamesTab:AddDropdown("GameList", {
    Values = {
        "Ink Game",
        "The Strongest Battle Grounds", 
        "99 Nights In the Forest",
        "Steal A Brainrot",
        "Murder Mystery 2",
        "Fling Things and People"
    },
    Default = 1,
    Text = "Select Game",
    Tooltip = "Choose a game to execute script",
    Callback = function(Value)
        SelectedGame = Value
        print("Selected game:", Value)
    end
})

GamesTab:AddDivider()

-- Кнопка для выполнения выбранного скрипта
local ExecuteButton = GamesTab:AddButton({
    Text = "🔑 Execute Selected Game",
    Func = function()
        if SelectedGame then
            Library:Notify("Executing: " .. SelectedGame)
            -- Выполняем соответствующий скрипт в зависимости от выбранной игры
            if SelectedGame == "Ink Game" then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/VapeVoidware/VW-Add/main/inkgame.lua", true))()
            elseif SelectedGame == "The Strongest Battle Grounds" then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/secretisadev/Phantasm/refs/heads/main/Games/TSB.lua"))()
            elseif SelectedGame == "99 Nights In the Forest" then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/VapeVoidware/VW-Add/main/nightsintheforest.lua", true))()
            elseif SelectedGame == "Steal A Brainrot" then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/tienkhanh1/spicy/main/Chilli.lua"))()
            elseif SelectedGame == "Murder Mystery 2" then
                loadstring(game:HttpGet("https://raw.githubusercontent.com/vertex-peak/vertex/refs/heads/main/loadstring"))()
            elseif SelectedGame == "Fling Things and People" then
                loadstring(game:HttpGet('https://raw.githubusercontent.com/Brovaky/Friendly/refs/heads/main/Friendly'))()
            end
        else
            Library:Notify("Please select a game first!")
            warn("Please select a game first!")
        end
    end,
    DoubleClick = true
})

GamesTab:AddDivider()

local TipGames = GamesTab:AddLabel("More games soon...")

-- Создаем вкладку Visual
local VisualTab = Visual:AddTab("Visual")

-- Переменные для ESP
local ESPEnabled = false
local ESPColor = Color3.fromRGB(255, 0, 0)
local ESPConnections = {}
local ESPObjects = {}

-- Функция для создания ESP для игрока
local function createESP(player)
    if ESPObjects[player] then return end
    
    local character = player.Character
    if not character then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "CubeESP"
    highlight.FillColor = ESPColor
    highlight.OutlineColor = ESPColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = character
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "CubeESPInfo"
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.Parent = character
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = ESPColor
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.BackgroundTransparency = 1
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.Parent = billboard
    
    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Text = "Distance: 0"
    distanceLabel.TextColor3 = ESPColor
    distanceLabel.TextSize = 12
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
    distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
    distanceLabel.Parent = billboard
    
    ESPObjects[player] = {
        Highlight = highlight,
        Billboard = billboard,
        NameLabel = nameLabel,
        DistanceLabel = distanceLabel
    }
    
    -- Обработчик обновления расстояния
    local connection = RunService.Heartbeat:Connect(function()
        if not ESPEnabled or not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local localPlayer = Players.LocalPlayer
        if not localPlayer or not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local playerPos = player.Character.HumanoidRootPart.Position
        local localPos = localPlayer.Character.HumanoidRootPart.Position
        local distance = (playerPos - localPos).Magnitude
        
        if ESPObjects[player] and ESPObjects[player].DistanceLabel then
            ESPObjects[player].DistanceLabel.Text = "Distance: " .. math.floor(distance)
        end
    end)
    
    table.insert(ESPConnections, connection)
end

-- Функция для удаления ESP игрока
local function removeESP(player)
    if ESPObjects[player] then
        if ESPObjects[player].Highlight then
            ESPObjects[player].Highlight:Destroy()
        end
        if ESPObjects[player].Billboard then
            ESPObjects[player].Billboard:Destroy()
        end
        ESPObjects[player] = nil
    end
end

-- Функция для обновления цвета ESP
local function updateESPColor()
    for player, espData in pairs(ESPObjects) do
        if espData.Highlight then
            espData.Highlight.FillColor = ESPColor
            espData.Highlight.OutlineColor = ESPColor
        end
        if espData.NameLabel then
            espData.NameLabel.TextColor3 = ESPColor
        end
        if espData.DistanceLabel then
            espData.DistanceLabel.TextColor3 = ESPColor
        end
    end
end

-- Функция для включения/выключения ESP
local function updateESP()
    -- Очищаем предыдущие соединения
    for _, connection in ipairs(ESPConnections) do
        connection:Disconnect()
    end
    ESPConnections = {}
    
    -- Очищаем предыдущие ESP объекты
    for player, espData in pairs(ESPObjects) do
        removeESP(player)
    end
    ESPObjects = {}
    
    if ESPEnabled then
        -- Создаем ESP для всех существующих игроков
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                if player.Character then
                    createESP(player)
                end
                
                -- Обработчик появления персонажа
                local connection = player.CharacterAdded:Connect(function(character)
                    wait(1) -- Ждем полной загрузки персонажа
                    if ESPEnabled then
                        createESP(player)
                    end
                end)
                table.insert(ESPConnections, connection)
            end
        end
        
        -- Обработчик новых игроков
        local playerAddedConnection = Players.PlayerAdded:Connect(function(player)
            if ESPEnabled then
                local connection = player.CharacterAdded:Connect(function(character)
                    wait(1) -- Ждем полной загрузки персонажа
                    if ESPEnabled then
                        createESP(player)
                    end
                end)
                table.insert(ESPConnections, connection)
            end
        end)
        table.insert(ESPConnections, playerAddedConnection)
        
        -- Обработчик ушедших игроков
        local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
            removeESP(player)
        end)
        table.insert(ESPConnections, playerRemovingConnection)
    end
end

-- Тоггл для ESP в VisualTab
local ESPToggle = VisualTab:AddToggle("ESP", {
    Text = "🌐 Player ESP",
    Default = false,
    Callback = function(Value)
        ESPEnabled = Value
        print("ESP enabled:", Value)
        updateESP()
    end
})

-- Добавляем ColorPicker для ESP
local ESPColorPicker = ESPToggle:AddColorPicker("ESPColor", {
    Default = Color3.fromRGB(255, 0, 0),
    Title = "ESP Color",
    Transparency = 0,
    Callback = function(Value)
        ESPColor = Value
        print("ESP color changed to:", Value)
        updateESPColor()
    end
})

-- Переменные для Anti-Lag
local AntiLagEnabled = false
local OriginalMaterials = {}
local OriginalTextures = {}
local antiLagConnection = nil

-- Функция для безопасного применения изменений к объекту
local function applyObjectSimplification(obj)
    if not obj or not obj.Parent then return end
    
    -- Для частей и мешей
    if obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") then
        -- Сохраняем оригинальный материал
        if not OriginalMaterials[obj] then
            OriginalMaterials[obj] = obj.Material
        end
        
        -- Применяем упрощенный материал
        pcall(function()
            obj.Material = Enum.Material.Plastic
        end)
        
        -- Сохраняем и убираем текстуру (если свойство существует)
        if not OriginalTextures[obj] then
            pcall(function()
                OriginalTextures[obj] = obj.TextureID
            end)
        end
        
        pcall(function()
            obj.TextureID = ""
        end)
        
        -- Убираем SurfaceAppearance
        pcall(function()
            local surfaceAppearance = obj:FindFirstChildOfClass("SurfaceAppearance")
            if surfaceAppearance then
                surfaceAppearance:Destroy()
            end
        end)
        
    -- Для декалей
    elseif obj:IsA("Decal") then
        if not OriginalMaterials[obj] then
            OriginalMaterials[obj] = true -- маркер что объект был
        end
        pcall(function()
            obj:Destroy()
        end)
    end
end

-- Функция для безопасного восстановления объекта
local function restoreObject(obj)
    if not obj or not obj.Parent then return end
    
    if obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") then
        -- Восстанавливаем материал
        if OriginalMaterials[obj] then
            pcall(function()
                obj.Material = OriginalMaterials[obj]
            end)
        end
        
        -- Восстанавливаем текстуру
        if OriginalTextures[obj] then
            pcall(function()
                obj.TextureID = OriginalTextures[obj]
            end)
        end
    end
end

-- Функция для применения Anti-Lag
local function applyAntiLag()
    if AntiLagEnabled then
        -- Применяем к существующим объектам
        for _, obj in pairs(workspace:GetDescendants()) do
            applyObjectSimplification(obj)
        end
    else
        -- Восстанавливаем оригинальные материалы и текстуры
        for obj, _ in pairs(OriginalMaterials) do
            restoreObject(obj)
        end
        
        -- Очищаем таблицы
        OriginalMaterials = {}
        OriginalTextures = {}
    end
end

-- Функция для обработки новых объектов
local function handleNewObjects(obj)
    if AntiLagEnabled then
        applyObjectSimplification(obj)
    end
end

-- Функция для обновления Anti-Lag
local function updateAntiLag()
    if antiLagConnection then
        antiLagConnection:Disconnect()
        antiLagConnection = nil
    end
    
    if AntiLagEnabled then
        -- Применяем к существующим объектам
        applyAntiLag()
        
        -- Настраиваем обработку новых объектов
        antiLagConnection = workspace.DescendantAdded:Connect(handleNewObjects)
        
        Library:Notify({
            Title = "Anti-Lag Enabled",
            Description = "Materials and textures simplified",
            Time = 3
        })
    else
        -- Восстанавливаем оригиналы
        applyAntiLag()
        
        Library:Notify({
            Title = "Anti-Lag Disabled",
            Description = "Original materials restored",
            Time = 3
        })
    end
end

-- Тоггл для Anti-Lag
local AntiLagToggle = VisualTab:AddToggle("AntiLag", {
    Text = "💢 Anti-Lag",
    Default = false,
    Callback = function(Value)
        AntiLagEnabled = Value
        print("Anti-Lag enabled:", Value)
        updateAntiLag()
    end
})

-- Переменные для X-Ray
local XRayEnabled = false
local OriginalTransparency = {}
local xRayConnection = nil

-- Функция для проверки, является ли объект частью персонажа
local function isPartOfCharacter(obj)
    local model = obj:FindFirstAncestorOfClass("Model")
    if model then
        local humanoid = model:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return true
        end
    end
    return false
end

-- Функция для применения X-Ray к объекту
local function applyXRay(obj)
    if not obj or not obj.Parent then return end
    
    -- Обрабатываем только части, которые не являются частью персонажа
    if (obj:IsA("Part") or obj:IsA("MeshPart") or obj:IsA("UnionOperation") or obj:IsA("TrussPart")) and not isPartOfCharacter(obj) then
        local currentTransparency = obj.Transparency
        
        -- Если текущая прозрачность меньше 0.5, то мы ее меняем
        if currentTransparency < 0.5 then
            -- Сохраняем оригинальную прозрачность, если еще не сохранили
            if not OriginalTransparency[obj] then
                OriginalTransparency[obj] = currentTransparency
            end
            
            -- Устанавливаем новую прозрачность
            pcall(function()
                obj.Transparency = 0.7 -- Можно настроить уровень прозрачности
            end)
        end
    end
end

-- Функция для восстановления оригинальной прозрачности объекта
local function restoreObjectTransparency(obj)
    if OriginalTransparency[obj] then
        pcall(function()
            obj.Transparency = OriginalTransparency[obj]
        end)
        OriginalTransparency[obj] = nil
    end
end

-- Функция для применения X-Ray ко всем объектам
local function applyXRayToAll()
    if XRayEnabled then
        -- Применяем к существующим объектам
        for _, obj in pairs(workspace:GetDescendants()) do
            applyXRay(obj)
        end
    else
        -- Восстанавливаем оригинальную прозрачность
        for obj, _ in pairs(OriginalTransparency) do
            restoreObjectTransparency(obj)
        end
        OriginalTransparency = {}
    end
end

-- Функция для обработки новых объектов X-Ray
local function handleNewXRayObjects(obj)
    if XRayEnabled then
        applyXRay(obj)
    end
end

-- Функция для обновления X-Ray
local function updateXRay()
    if xRayConnection then
        xRayConnection:Disconnect()
        xRayConnection = nil
    end
    
    if XRayEnabled then
        -- Применяем к существующим объектам
        applyXRayToAll()
        
        -- Настраиваем обработку новых объектов
        xRayConnection = workspace.DescendantAdded:Connect(handleNewXRayObjects)
        
        Library:Notify({
            Title = "X-Ray Enabled",
            Description = "You can now see through walls",
            Time = 3
        })
    else
        -- Восстанавливаем оригиналы
        applyXRayToAll()
        
        Library:Notify({
            Title = "X-Ray Disabled",
            Description = "Walls are now opaque again",
            Time = 3
        })
    end
end

-- Тоггл для X-Ray
local XRayToggle = VisualTab:AddToggle("XRay", {
    Text = "💫 Xray",
    Default = false,
    Callback = function(Value)
        XRayEnabled = Value
        print("X-Ray enabled:", Value)
        updateXRay()
    end
})

-- Слайдер для настройки прозрачности X-Ray
local XRayTransparencySlider = VisualTab:AddSlider("XRayTransparency", {
    Text = "X-Ray Transparency",
    Default = 70,
    Min = 10,
    Max = 90,
    Rounding = 0,
    Suffix = "%",
    Callback = function(Value)
        -- Обновляем прозрачность для всех объектов, если X-Ray включен
        if XRayEnabled then
            for obj, _ in pairs(OriginalTransparency) do
                if obj and obj.Parent then
                    pcall(function()
                        obj.Transparency = Value / 100
                    end)
                end
            end
        end
    end
})

-- Переменные для FullBright
local FullBrightEnabled = false
local OriginalLightingSettings = {}
local lighting = game:GetService("Lighting")

-- Функция для применения FullBright
local function applyFullBright()
    if FullBrightEnabled then
        -- Сохраняем оригинальные настройки освещения
        if not next(OriginalLightingSettings) then
            OriginalLightingSettings = {
                Ambient = lighting.Ambient,
                Brightness = lighting.Brightness,
                GlobalShadows = lighting.GlobalShadows,
                OutdoorAmbient = lighting.OutdoorAmbient,
                ClockTime = lighting.ClockTime,
                FogStart = lighting.FogStart,
                FogEnd = lighting.FogEnd,
                FogColor = lighting.FogColor,
                ExposureCompensation = lighting.ExposureCompensation
            }
        end
        
        -- Применяем настройки FullBright
        pcall(function()
            lighting.Ambient = Color3.new(1, 1, 1) -- Белый ambient свет
            lighting.Brightness = 2 -- Увеличиваем яркость
            lighting.GlobalShadows = false -- Отключаем тени
            lighting.OutdoorAmbient = Color3.new(1, 1, 1) -- Белый outdoor ambient
            lighting.ClockTime = 14 -- Устанавливаем дневное время
            lighting.FogStart = 100000 -- Убираем туман
            lighting.FogEnd = 100000
            lighting.ExposureCompensation = 1 -- Компенсация экспозиции
        end)
    else
        -- Восстанавливаем оригинальные настройки
        if next(OriginalLightingSettings) then
            pcall(function()
                lighting.Ambient = OriginalLightingSettings.Ambient or Color3.new(0.5, 0.5, 0.5)
                lighting.Brightness = OriginalLightingSettings.Brightness or 1
                lighting.GlobalShadows = OriginalLightingSettings.GlobalShadows or true
                lighting.OutdoorAmbient = OriginalLightingSettings.OutdoorAmbient or Color3.new(0.5, 0.5, 0.5)
                lighting.ClockTime = OriginalLightingSettings.ClockTime or 14
                lighting.FogStart = OriginalLightingSettings.FogStart or 0
                lighting.FogEnd = OriginalLightingSettings.FogEnd or 100000
                lighting.FogColor = OriginalLightingSettings.FogColor or Color3.new(1, 1, 1)
                lighting.ExposureCompensation = OriginalLightingSettings.ExposureCompensation or 0
            end)
            OriginalLightingSettings = {}
        end
    end
end

-- Функция для обновления FullBright
local function updateFullBright()
    applyFullBright()
    
    if FullBrightEnabled then
        Library:Notify({
            Title = "FullBright Enabled",
            Description = "Shadows removed and brightness increased",
            Time = 3
        })
    else
        Library:Notify({
            Title = "FullBright Disabled",
            Description = "Lighting restored to normal",
            Time = 3
        })
    end
end

-- Тоггл для FullBright
local FullBrightToggle = VisualTab:AddToggle("FullBright", {
    Text = "🔆 FullBright",
    Default = false,
    Callback = function(Value)
        FullBrightEnabled = Value
        print("FullBright enabled:", Value)
        updateFullBright()
    end
})

-- Слайдер для настройки яркости
local BrightnessSlider = VisualTab:AddSlider("BrightnessLevel", {
    Text = "Brightness Level",
    Default = 1,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        if FullBrightEnabled then
            pcall(function()
                lighting.Brightness = Value
            end)
        end
    end
})

-- Переменные для Stop Rendering
local StopRenderingEnabled = false
local originalSettings = {}
local blackScreen = nil

-- Функция для сохранения всех текущих настроек
local function saveOriginalSettings()
    local lighting = game:GetService("Lighting")
    local settings = settings()
    
    originalSettings = {
        -- Настройки освещения
        Ambient = lighting.Ambient,
        Brightness = lighting.Brightness,
        GlobalShadows = lighting.GlobalShadows,
        OutdoorAmbient = lighting.OutdoorAmbient,
        ClockTime = lighting.ClockTime,
        FogStart = lighting.FogStart,
        FogEnd = lighting.FogEnd,
        FogColor = lighting.FogColor,
        ExposureCompensation = lighting.ExposureCompensation,
        
        -- Настройки графики
        QualityLevel = settings.Rendering.QualityLevel,
        EagerBulkExecution = settings.Rendering.EagerBulkExecution,
        
        -- Состояние эффектов
        Effects = {}
    }
    
    -- Сохраняем состояние всех визуальных эффектов (только те, у которых есть свойство Enabled)
    for _, effect in pairs(lighting:GetChildren()) do
        if effect:IsA("BlurEffect") or effect:IsA("SunRaysEffect") or 
           effect:IsA("ColorCorrectionEffect") or effect:IsA("BloomEffect") or
           effect:IsA("DepthOfFieldEffect") then
            originalSettings.Effects[effect] = {
                Enabled = effect.Enabled,
                Parent = effect.Parent
            }
        elseif effect:IsA("Atmosphere") then
            -- Для Atmosphere сохраняем другие свойства, так как у него нет Enabled
            originalSettings.Effects[effect] = {
                Density = effect.Density,
                Offset = effect.Offset,
                Color = effect.Color,
                Decay = effect.Decay,
                Glare = effect.Glare,
                Haze = effect.Haze,
                Parent = effect.Parent
            }
        end
    end
end

-- Функция для восстановления всех настроек
local function restoreOriginalSettings()
    local lighting = game:GetService("Lighting")
    local settings = settings()
    
    -- Восстанавливаем настройки освещения
    pcall(function()
        lighting.Ambient = originalSettings.Ambient or Color3.new(0.5, 0.5, 0.5)
        lighting.Brightness = originalSettings.Brightness or 1
        lighting.GlobalShadows = originalSettings.GlobalShadows or true
        lighting.OutdoorAmbient = originalSettings.OutdoorAmbient or Color3.new(0.5, 0.5, 0.5)
        lighting.ClockTime = originalSettings.ClockTime or 14
        lighting.FogStart = originalSettings.FogStart or 0
        lighting.FogEnd = originalSettings.FogEnd or 100000
        lighting.FogColor = originalSettings.FogColor or Color3.new(1, 1, 1)
        lighting.ExposureCompensation = originalSettings.ExposureCompensation or 0
    end)
    
    -- Восстанавливаем настройки графики
    pcall(function()
        settings.Rendering.QualityLevel = originalSettings.QualityLevel or 10
        settings.Rendering.EagerBulkExecution = originalSettings.EagerBulkExecution or false
    end)
    
    -- Восстанавливаем эффекты
    for effect, data in pairs(originalSettings.Effects or {}) do
        if effect and data.Parent then
            pcall(function()
                if effect:IsA("Atmosphere") then
                    -- Восстанавливаем свойства Atmosphere
                    effect.Density = data.Density or 0
                    effect.Offset = data.Offset or 0
                    effect.Color = data.Color or Color3.new(1, 1, 1)
                    effect.Decay = data.Decay or Color3.new(1, 1, 1)
                    effect.Glare = data.Glare or 0
                    effect.Haze = data.Haze or 0
                else
                    -- Восстанавливаем обычные эффекты
                    effect.Enabled = data.Enabled
                end
            end)
        end
    end
    
    originalSettings = {}
end

-- Функция для применения Stop Rendering
local function applyStopRendering()
    if StopRenderingEnabled then
        -- Сохраняем оригинальные настройки
        saveOriginalSettings()
        
        local lighting = game:GetService("Lighting")
        
        -- Минимизируем настройки графики
        pcall(function()
            settings().Rendering.QualityLevel = 1
            lighting.GlobalShadows = false
            lighting.FogEnd = 9e9
            
            -- Отключаем различные визуальные эффекты (только те, у которых есть свойство Enabled)
            for _, effect in pairs(lighting:GetChildren()) do
                if effect:IsA("BlurEffect") or effect:IsA("SunRaysEffect") or 
                   effect:IsA("ColorCorrectionEffect") or effect:IsA("BloomEffect") or
                   effect:IsA("DepthOfFieldEffect") then
                    pcall(function()
                        effect.Enabled = false
                    end)
                elseif effect:IsA("Atmosphere") then
                    -- Для Atmosphere устанавливаем нулевые значения
                    pcall(function()
                        effect.Density = 0
                        effect.Offset = 0
                        effect.Glare = 0
                        effect.Haze = 0
                    end)
                end
            end
            
            -- Включаем оптимизацию рендеринга
            settings().Rendering.EagerBulkExecution = true
        end)
        
        -- Создаем черный экран
        blackScreen = Instance.new("ScreenGui")
        blackScreen.Name = "StopRenderingScreen"
        blackScreen.IgnoreGuiInset = true
        blackScreen.ResetOnSpawn = false
        
        local blackFrame = Instance.new("Frame")
        blackFrame.Size = UDim2.new(1, 0, 1, 0)
        blackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
        blackFrame.BorderSizePixel = 0
        blackFrame.Parent = blackScreen
        
        blackScreen.Parent = game:GetService("CoreGui")
        
        Library:Notify({
            Title = "Stop Rendering Enabled",
            Description = "Graphics minimized for maximum FPS",
            Time = 3
        })
    else
        -- Восстанавливаем оригинальные настройки
        restoreOriginalSettings()
        
        -- Удаляем черный экран
        pcall(function()
            if blackScreen then
                blackScreen:Destroy()
                blackScreen = nil
            end
        end)
        
        Library:Notify({
            Title = "Stop Rendering Disabled",
            Description = "Graphics restored to original settings",
            Time = 3
        })
    end
end

-- Тоггл для Stop Rendering
local StopRenderingToggle = VisualTab:AddToggle("StopRendering", {
    Text = "🔺 Stop Rendering",
    Default = false,
    Callback = function(Value)
        StopRenderingEnabled = Value
        print("Stop Rendering enabled:", Value)
        applyStopRendering()
    end
})

VisualTab:AddDivider()

local Button2 = VisualTab:AddButton({
 Text = "🪐 Freecam",
 Func = function()
 print("Freecam Loaded")
 loadstring(game:HttpGet("https://raw.githubusercontent.com/snigglaberry/freecam/main/freecam.lua.txt"))()
 Library:Notify("Made by Snigglaberry")
 Library:Notify("Loaded Freecam!")
 end,
 DoubleClick = false -- Requires double-click for risky actions
})

-- Переменные для Walk Speed
local WalkSpeedEnabled = false
local CurrentSpeed = 16

-- Переменные для Jump Power
local JumpPowerEnabled = false
local CurrentJumpPower = 50

-- Переменные для Infinite Jump
local InfiniteJumpEnabled = false

-- Переменные для Noclip
local NoclipEnabled = false
local NoclipConnection = nil

-- Переменная для хранения выбранного игрока
local SelectedPlayer = nil

-- Функция обновления скорости ходьбы
local function updateWalkSpeed()
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = WalkSpeedEnabled and CurrentSpeed or 16
        end
    end
end

-- Функция обновления силы прыжка
local function updateJumpPower()
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.JumpPower = JumpPowerEnabled and CurrentJumpPower or 50
        end
    end
end

-- Функция для обработки бесконечного прыжка
local function handleJump(input)
    if input.KeyCode == Enum.KeyCode.Space then
        if InfiniteJumpEnabled then
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end
    end
end

-- Функция для активации/деактивации Noclip
local function updateNoclip()
    if NoclipConnection then
        NoclipConnection:Disconnect()
        NoclipConnection = nil
    end
    
    if NoclipEnabled then
        NoclipConnection = RunService.Stepped:Connect(function()
            local character = player.Character
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        -- Восстанавливаем коллизию при выключении
        local character = player.Character
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- Общая функция обновления для всех параметров
local function updateCharacterStats()
    updateWalkSpeed()
    updateJumpPower()
end

-- Обработчик изменения персонажа
player.CharacterAdded:Connect(function(character)
    character:WaitForChild("Humanoid")
    updateCharacterStats()
    
    -- При появлении нового персонажа обновляем Noclip
    if NoclipEnabled then
        updateNoclip()
    end
end)

-- Подключаем обработчик ввода для Infinite Jump
UserInputService.InputBegan:Connect(handleJump)

-- Применяем настройки к существующему персонажу
if player.Character then
    updateCharacterStats()
end

-- Тогл для Walk Speed
local WalkSpeedToggle = GeneralTab:AddToggle("WalkSpeed", {
    Text = "👟 Custom Walk Speed",
    Default = false,
    Callback = function(Value)
        WalkSpeedEnabled = Value
        print("Walk Speed enabled:", Value)
        updateWalkSpeed()
    end
})

-- Слайдер для Walk Speed
local SpeedSlider = GeneralTab:AddSlider("SpeedValue", {
    Text = "Speed Value",
    Default = 16,
    Min = 16,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        CurrentSpeed = Value
        print("Speed set to:", Value)
        if WalkSpeedEnabled then
            updateWalkSpeed()
        end
    end
})

-- Тогл для Jump Power
local JumpPowerToggle = GeneralTab:AddToggle("JumpPower", {
    Text = "💨 Custom Jump Power",
    Default = false,
    Callback = function(Value)
        JumpPowerEnabled = Value
        print("Jump Power enabled:", Value)
        updateJumpPower()
    end
})

-- Слайдер для Jump Power
local JumpSlider = GeneralTab:AddSlider("JumpValue", {
    Text = "Jump Value",
    Default = 50,
    Min = 50,
    Max = 250,
    Rounding = 0,
    Callback = function(Value)
        CurrentJumpPower = Value
        print("Jump set to:", Value)
        if JumpPowerEnabled then
            updateJumpPower()
        end
    end
})

-- Тогл для Infinite Jump
local InfiniteJumpToggle = GeneralTab:AddToggle("InfiniteJump", {
    Text = "⚡ Infinite Jump",
    Default = false,
    Callback = function(Value)
        InfiniteJumpEnabled = Value
        print("Infinite Jump enabled:", Value)
    end
})

-- Тогл для Noclip
local NoclipToggle = GeneralTab:AddToggle("Noclip", {
    Text = "⭐ Noclip",
    Default = false,
    Callback = function(Value)
        NoclipEnabled = Value
        print("Noclip enabled:", Value)
        updateNoclip()
    end
})

-- Переменные для God Mode
local GodModeEnabled = false
local godModeConnections = {}

-- Функция для включения God Mode
local function enableGodMode(character)
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Сохраняем оригинальное максимальное здоровье
    local originalMaxHealth = humanoid.MaxHealth
    
    -- Устанавливаем бессмертие
    humanoid.MaxHealth = math.huge
    humanoid.Health = math.huge
    
    -- Защита от получения урона
    local healthConnection = humanoid.HealthChanged:Connect(function(newHealth)
        if GodModeEnabled and newHealth < math.huge then
            humanoid.Health = math.huge
        end
    end)
    
    -- Защита от смерти
    local diedConnection = humanoid.Died:Connect(function()
        if GodModeEnabled then
            -- Немедленно возрождаем персонажа
            humanoid.Health = math.huge
        end
    end)
    
    -- Защита от изменения максимального здоровья
    local maxHealthConnection
    maxHealthConnection = humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
        if GodModeEnabled and humanoid.MaxHealth ~= math.huge then
            humanoid.MaxHealth = math.huge
        end
    end)
    
    -- Отключаем возможность умирать от падения
    if humanoid:FindFirstChild("FallDamage") then
        humanoid.FallDamage:Destroy()
    end
    
    table.insert(godModeConnections, healthConnection)
    table.insert(godModeConnections, diedConnection)
    table.insert(godModeConnections, maxHealthConnection)
end

-- Функция для отключения God Mode
local function disableGodMode()
    -- Отключаем все соединения
    for _, connection in ipairs(godModeConnections) do
        pcall(function()
            connection:Disconnect()
        end)
    end
    godModeConnections = {}
    
    -- Восстанавливаем нормальное здоровье персонажа
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            pcall(function()
                humanoid.MaxHealth = 100 -- Стандартное значение
                humanoid.Health = math.min(humanoid.Health, humanoid.MaxHealth)
            end)
        end
    end
end

-- Функция для обновления God Mode
local function updateGodMode()
    if GodModeEnabled then
        -- Включаем God Mode для текущего персонажа
        if player.Character then
            enableGodMode(player.Character)
        end
        
        -- Обработчик для нового персонажа
        local characterConnection = player.CharacterAdded:Connect(function(character)
            if GodModeEnabled then
                wait(1) -- Ждем полной загрузки персонажа
                enableGodMode(character)
            end
        end)
        
        table.insert(godModeConnections, characterConnection)
        
        Library:Notify({
            Title = "God Mode Enabled",
            Description = "You are now invincible",
            Time = 3
        })
    else
        -- Отключаем God Mode
        disableGodMode()
        
        Library:Notify({
            Title = "God Mode Disabled",
            Description = "You can now take damage",
            Time = 3
        })
    end
end

-- Тоггл для God Mode
local GodModeToggle = GeneralTab:AddToggle("GodMode", {
    Text = "🌠 God Mode",
    Default = false,
    Callback = function(Value)
        GodModeEnabled = Value
        print("God Mode enabled:", Value)
        updateGodMode()
    end
})

-- Переменные для Fly
local FlyEnabled = false
local FlyConnection = nil
local FlySpeed = 50
local BodyVelocity = nil
local BodyGyro = nil

-- Функция для активации/деактивации полета
local function updateFly()
    if FlyConnection then
        FlyConnection:Disconnect()
        FlyConnection = nil
    end
    
    if BodyVelocity then
        BodyVelocity:Destroy()
        BodyVelocity = nil
    end
    
    if BodyGyro then
        BodyGyro:Destroy()
        BodyGyro = nil
    end
    
    if FlyEnabled then
        local character = player.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Создаем BodyGyro для стабилизации
                BodyGyro = Instance.new("BodyGyro")
                BodyGyro.P = 10000
                BodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
                BodyGyro.CFrame = humanoidRootPart.CFrame
                BodyGyro.Parent = humanoidRootPart
                
                -- Создаем BodyVelocity для движения
                BodyVelocity = Instance.new("BodyVelocity")
                BodyVelocity.Velocity = Vector3.new(0, 0, 0)
                BodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
                BodyVelocity.Parent = humanoidRootPart
                
                -- Включаем PlatformStand для отключения физики
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.PlatformStand = true
                end
                
                -- Обработчик полета
                FlyConnection = RunService.Heartbeat:Connect(function()
                    if not FlyEnabled or not character or not humanoidRootPart then
                        return
                    end
                    
                    local camera = workspace.CurrentCamera
                    local direction = Vector3.new(0, 0, 0)
                    
                    -- Обработка клавиш движения
                    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                        direction = direction + camera.CFrame.LookVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                        direction = direction - camera.CFrame.LookVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                        direction = direction - camera.CFrame.RightVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                        direction = direction + camera.CFrame.RightVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        direction = direction + Vector3.new(0, 1, 0)
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                        direction = direction - Vector3.new(0, 1, 0)
                    end
                    
                    -- Применяем скорость
                    if direction.Magnitude > 0 then
                        BodyVelocity.Velocity = direction.Unit * FlySpeed
                    else
                        BodyVelocity.Velocity = Vector3.new(0, 0, 0)
                    end
                    
                    -- Обновляем BodyGyro
                    BodyGyro.CFrame = camera.CFrame
                end)
            end
        end
    else
        -- Выключаем PlatformStand при отключении полета
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.PlatformStand = false
            end
        end
    end
end

-- Обработчик изменения персонажа для полета
player.CharacterAdded:Connect(function(character)
    if FlyEnabled then
        wait(1) -- Ждем полной загрузки персонажа
        updateFly()
    end
end)

-- Тоггл для Fly с ключевой привязкой
local FlyToggle = GeneralTab:AddToggle("Fly", {
    Text = "🔰 Fly",
    Default = false,
    Callback = function(Value)
        FlyEnabled = Value
        print("Fly enabled:", Value)
        updateFly()
    end
})

-- Добавляем ключевую привязку для полета
local FlyKeybind = FlyToggle:AddKeyPicker("FlyKeybind", {
    Default = "F",
    Text = "Fly Keybind",
    Mode = "Toggle", -- Режим: "Toggle", "Hold", "Always"
    
    -- Синхронизирует состояние тоггла с состоянием ключевой привязки
    SyncToggleState = true,
    
    Callback = function(Value)
        print("Fly keybind pressed, value:", Value)
        -- Не нужно вызывать updateFly() здесь, так как SyncToggleState = true
        -- автоматически изменит состояние тоггла, который вызовет updateFly()
    end
})

-- Слайдер для скорости полета
local FlySpeedSlider = GeneralTab:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Default = 50,
    Min = 20,
    Max = 200,
    Rounding = 0,
    Callback = function(Value)
        FlySpeed = Value
        print("Fly speed set to:", Value)
    end
})

-- Config section
local SaveBox = ConfigTab:AddLeftGroupbox("Save Configuration")

local ConfigNameInput = SaveBox:AddInput("ConfigName", {
    Text = "Config Name",
    Default = "MyConfig",
    Placeholder = "Enter name...",
    Finished = true
})

-- Функция для сохранения конфигурации
local function saveConfig()
    local name = Library.Options.ConfigName.Value
    if name == "" then
        Library:Notify({
            Title = "Error",
            Description = "Please enter a config name",
            Time = 3
        })
        return
    end
    
    local config = {
        WalkSpeed = {
            Enabled = WalkSpeedEnabled,
            Value = CurrentSpeed
        },
        JumpPower = {
            Enabled = JumpPowerEnabled,
            Value = CurrentJumpPower
        },
        InfiniteJump = {
            Enabled = InfiniteJumpEnabled
        },
        Noclip = {
            Enabled = NoclipEnabled
        },
        Fly = {
            Enabled = FlyEnabled,
            Speed = FlySpeed
        }
    }
    
    -- Сохраняем конфиг в DataStore (или другом месте)
    local success, message = pcall(function()
        -- Здесь можно добавить сохранение в DataStore или файл
        -- Например: game:GetService("DataStoreService"):GetDataStore("CubeHelper"):SetAsync(name, config)
        print("Config saved:", name)
        return true
    end)
    
    if success then
        Library:Notify({
            Title = "Config Saved",
            Description = "Saved configuration as " .. name,
            Time = 3
        })
    else
        Library:Notify({
            Title = "Error",
            Description = "Failed to save config: " .. tostring(message),
            Time = 3
        })
    end
end

-- Функция для загрузки конфигурации
local function loadConfig()
    local name = Library.Options.ConfigName.Value
    if name == "" then
        Library:Notify({
            Title = "Error",
            Description = "Please enter a config name",
            Time = 3
        })
        return
    end
    
    local success, config = pcall(function()
        -- Здесь можно добавить загрузку из DataStore или файла
        -- Например: return game:GetService("DataStoreService"):GetDataStore("CubeHelper"):GetAsync(name)
        
        -- Временный пример конфига для демонстрации
        return {
            WalkSpeed = {
                Enabled = true,
                Value = 50
            },
            JumpPower = {
                Enabled = false,
                Value = 100
            },
            InfiniteJump = {
                Enabled = true
            },
            Noclip = {
                Enabled = false
            },
            Fly = {
                Enabled = true,
                Speed = 75
            }
        }
    end)
    
    if success and config then
        -- Применяем настройки WalkSpeed
        if config.WalkSpeed then
            WalkSpeedEnabled = config.WalkSpeed.Enabled
            CurrentSpeed = config.WalkSpeed.Value
            if Library.Options.WalkSpeed then
                Library.Options.WalkSpeed:SetValue(WalkSpeedEnabled)
            end
            if Library.Options.SpeedValue then
                Library.Options.SpeedValue:SetValue(CurrentSpeed)
            end
            updateWalkSpeed()
        end
        
        -- Применяем настройки JumpPower
        if config.JumpPower then
            JumpPowerEnabled = config.JumpPower.Enabled
            CurrentJumpPower = config.JumpPower.Value
            if Library.Options.JumpPower then
                Library.Options.JumpPower:SetValue(JumpPowerEnabled)
            end
            if Library.Options.JumpValue then
                Library.Options.JumpValue:SetValue(CurrentJumpPower)
            end
            updateJumpPower()
        end
        
        -- Применяем настройки InfiniteJump
        if config.InfiniteJump then
            InfiniteJumpEnabled = config.InfiniteJump.Enabled
            if Library.Options.InfiniteJump then
                Library.Options.InfiniteJump:SetValue(InfiniteJumpEnabled)
            end
        end
        
        -- Применяем настройки Noclip
        if config.Noclip then
            NoclipEnabled = config.Noclip.Enabled
            if Library.Options.Noclip then
                Library.Options.Noclip:SetValue(NoclipEnabled)
            end
            updateNoclip()
        end
        
        -- Применяем настройки Fly
        if config.Fly then
            FlyEnabled = config.Fly.Enabled
            FlySpeed = config.Fly.Speed or 50
            if Library.Options.Fly then
                Library.Options.Fly:SetValue(FlyEnabled)
            end
            if Library.Options.FlySpeed then
                Library.Options.FlySpeed:SetValue(FlySpeed)
            end
            updateFly()
        end
        
        Library:Notify({
            Title = "Config Loaded",
            Description = "Loaded configuration " .. name,
            Time = 3
        })
    else
        Library:Notify({
            Title = "Error",
            Description = "Failed to load config: " .. tostring(config),
            Time = 3
        })
    end
end

SaveBox:AddButton({
    Text = "Save Config",
    Func = saveConfig
})

SaveBox:AddButton({
    Text = "Load Config",
    Func = loadConfig
})

SaveBox:AddButton({
    Text = "Reset All",
    Func = function()
        -- Сбрасываем все настройки
        WalkSpeedEnabled = false
        CurrentSpeed = 16
        JumpPowerEnabled = false
        CurrentJumpPower = 50
        InfiniteJumpEnabled = false
        NoclipEnabled = false
        FlyEnabled = false
        FlySpeed = 50
        
        -- Сбрасываем UI элементы
        if Library.Options.WalkSpeed then Library.Options.WalkSpeed:SetValue(false) end
        if Library.Options.SpeedValue then Library.Options.SpeedValue:SetValue(16) end
        if Library.Options.JumpPower then Library.Options.JumpPower:SetValue(false) end
        if Library.Options.JumpValue then Library.Options.JumpValue:SetValue(50) end
        if Library.Options.InfiniteJump then Library.Options.InfiniteJump:SetValue(false) end
        if Library.Options.Noclip then Library.Options.Noclip:SetValue(false) end
        if Library.Options.Fly then Library.Options.Fly:SetValue(false) end
        if Library.Options.FlySpeed then Library.Options.FlySpeed:SetValue(50) end
        
        -- Обновляем состояние
        updateWalkSpeed()
        updateJumpPower()
        updateNoclip()
        updateFly()
        
        Library:Notify({
            Title = "Reset Complete",
            Description = "All settings have been reset to default",
            Time = 3
        })
    end
})

-- Theme settings
local ThemeBox = ConfigTab:AddRightGroupbox("UI Settings")

local CreditsBox = ConfigTab:AddLeftGroupbox("Credits")

local CreditsLabel1 = CreditsBox:AddLabel({
 Text = "Owner&scripter - ItsCube_Win",
 DoesWrap = true
})

local CreditsLabel2 = CreditsBox:AddLabel({
 Text = "Tester&friend - Chpoker",
 DoesWrap = true
})

local CreditsLabel3 = CreditsBox:AddLabel({
 Text = "Thanks infinite yield ❤",
 DoesWrap = true
})

local CreditsLabel3 = CreditsBox:AddLabel({
 Text = "Thanks Obsidian Ui ❤",
 DoesWrap = true
})

local Viewport = CreditsBox:AddViewport("MyViewport", {
    Object = Instance.new("Part"),
    Camera = Instance.new("Camera"),
    Interactive = true,
    AutoFocus = true
})

CreditsBox:AddDivider()

local CreditsLabel = CreditsBox:AddLabel({
 Text = "As reward thats you use this hub you get a basic part.. So funny",
 DoesWrap = true
})

local UIScaleSlider = ThemeBox:AddSlider("UIScale", {
    Text = "UI Scale",
    Default = 100,
    Min = 75,
    Max = 150,
    Rounding = 0,
    Suffix = "%",
    Callback = function(Value)
        Library:SetDPIScale(Value)
    end
})



local ConfigTip = SaveBox:AddLabel({
    Text = "Config is broken or work not correctly sorry..",
    DoesWrap = true
})

-- Sets the watermark visibility
Library:SetWatermarkVisibility(true)

-- Example of dynamically-updating watermark with common traits (fps and ping)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;

    Library:SetWatermark(('Cube Helper+ | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);

-- Set a keybind toggler
ThemeBox:AddLabel("Press Right-Ctrl to toggle the UI")

local InfoSocial = InfoTab:AddLeftGroupbox("Social Media", "wrench")

local InfoAbout = InfoTab:AddRightGroupbox("About", "wrench")

local InfoChangelogs = InfoTab:AddLeftGroupbox("Changelogs", "wrench")

local Changelog = InfoChangelogs:AddLabel({
    Text = "1.09v",
    DoesWrap = true
})

local Changelog = InfoChangelogs:AddLabel({
    Text = "Made more options in info tab and change default color to green..",
    DoesWrap = true
})


local WrappedLabel1 = InfoSocial:AddLabel({
    Text = "Thanks you for using Cube's hub❤",
    DoesWrap = true
})

-- Функция для определения экзекутора
local function getExecutorName()
    -- Проверяем различные экзекуторы по их уникальным функциям/переменным
    if syn and syn.request then
        return "Synapse X"
    elseif PROTOSMASHER_LOADED then
        return "ProtoSmasher"
    elseif sentinel then
        return "Sentinel"
    elseif Krnl then
        return "Krnl"
    elseif fluxus then
        return "Fluxus"
    elseif identifyexecutor then
        local success, result = pcall(identifyexecutor)
        if success and result then
            return result
        end
        return "Unknown (identifyexecutor exists)"
    elseif getexecutorname then
        local success, result = pcall(getexecutorname)
        if success and result then
            return result
        end
        return "Unknown (getexecutorname exists)"
    elseif is_sirhurt_closure then
        return "SirHurt"
    elseif is_fluxus then
        return "Fluxus"
    elseif is_krnl then
        return "Krnl"
    elseif get_hui_animation then
        return "ScriptWare"
    elseif OXYGEN_LOADED then
        return "Oxygen U"
    elseif ELECTRON_LOADED then
        return "Electron"
    elseif comet then
        return "Comet"
    elseif pepeg then
        return "Pepe"
    elseif is_whiteshadow then
        return "WhiteShadow"
    elseif is_synapse_function then
        return "Synapse X"
    -- Добавленные экзекуторы
    elseif Xeno then
        return "Xeno"
    elseif Delta then
        return "Delta X"
    elseif Swift then
        return "Swift"
    elseif Velocity then
        return "Velocity"
    elseif Volcan then
        return "Volcan"
    elseif Zenith then
        return "Zenith"
    elseif Seliware then
        return "Seliware"
    elseif Solara then
        return "Solara"
    else
        -- Если не удалось определить, пробуем другие методы
        local env = getfenv()
        for k, v in pairs(env) do
            if type(k) == "string" and k:lower():find("executor") then
                return "Unknown (" .. k .. ")"
            end
        end
        
        -- Дополнительные проверки для специфических экзекуторов
        if type(writefile) == "function" and type(readfile) == "function" then
            if pcall(function() return getrenv()._G end) then
                return "Unknown (File functions available)"
            end
        end
        
        return "Unknown Executor"
    end
end

-- Создаем Label с информацией об экзекуторе
local InfoStatus = InfoAbout:AddLabel({
    Text = "Your executor: " .. getExecutorName(),
    DoesWrap = true
})

InfoAbout:AddDivider()

local InfoStatus1 = InfoAbout:AddLabel({
    Text = "Thanks you to buy Premium ❤",
    DoesWrap = true
})


InfoSocial:AddDivider()

local WrappedLabel1 = InfoSocial:AddLabel({
    Text = "Owner Official links",
    DoesWrap = true
})

InfoSocial:AddButton({
    Text = "Tiktok",
    Func = function()
        local url = "https://www.tiktok.com/@itscube_gg"
        
        -- Для ПК
        if setclipboard then
            setclipboard(url)
        -- Для мобильных устройств и других случаев
        else
            -- Создаем временный текстовый элемент для копирования
            local tempText = Instance.new("TextBox")
            tempText.Text = url
            tempText.ClearTextOnFocus = false
            tempText.Parent = game:GetService("CoreGui")
            tempText:CaptureFocus()
            tempText:SelectAll()
            tempText:ReleaseFocus()
            tempText:Destroy()
        end
        
        Library:Notify({
            Title = "Copied",
            Description = "TikTok link copied to clipboard!",
            Time = 5,
        })
    end
})

InfoSocial:AddButton({
    Text = "Discord [Making.]",
    Func = function()
        Library:Notify({
    Title = "Nothing is copied",
    Description = "We dont have discord server try again later...",
    Time = 5, -- Duration in seconds
})
    end
})

-- Show the UI
Library:Toggle(true)

Library:Notify({
    Title = "Success!",
    Description = "Hub loaded",
    Time = 5, -- Duration in seconds
    SoundId = 18755588842 -- Optional sound ID
})
